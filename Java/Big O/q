Example 13
===========
The following code computes the Nth Fibonacci number.
1 int fib(int n) {
2   if (n <= 0) return 0;
3   else if (n == 1) return 1;
4   return fib(n - 1) + fib(n - 2);
5 }
We can use the earlier pattern we'd established for recursive calls: O(branchesdepth).
There are 2 branches per call, and we go as deep as N, therefore the runtime is O(2 raisedTo N).

Through some very complicated math, we can actually get a tighter runtime. The time is indeed
exponential, but it's actually closer to O(1.6 raisedTo N). The reason that it's not exactly O(2 raisedTo N) is that, at
the bottom of the call stack, there is sometimes only one call. It turns out that a lot of the nodes
are at the bottom (as is true in most trees), so this single versus double call actually makes a big
difference. Saying O(2 raisedTo N) would suffice for the scope of an interview, though (and is still technically
correct, if you read the note about big theta on page 39). You might get "bonus points" if
you can recognize that it'll actually be less than that.

Generally speaking, when you see an algorithm with multiple recursive calls, you're looking at exponential
runtime.

Example14
==========
The following code prints all Fibonacci numbers from 0 to n. What is its time complexity?
1 void allFib(int n) {
2   for (int i= 0; i < n; i++) {
3     System.out.println(i + ": "+ fib(i));
4   }
5 }
6
7 int fib(int n) {
8   if (n <= 0) 
      return 0;
9   else if (n == 1) return 1;
10    return fib(n - 1) + fib(n - 2);
11 }
Many people will rush to concluding that since fib(n) takes O(2 rasiedTo n) time and it's called n times, then it's
O(n *(2 raisedTo n)).
Not so fast. Can you find the error in the logic?
The error is that the n is changing. Yes, fib (n) takes 0(2 raisedTo n) time, but it matters what that value of n is.
Instead, let's walk through each call.
fib(1) -> 2 raisedTo 1 steps
fib(2) -> 2 raisedTo 2 steps
fib(3) -> 2 raisedTo 3 steps
fib(4) -> 2 raisedTo 4 steps
fib(n) -> 2 raisedTo n steps
Therefore, the total amount of work is:
2 raisedTo 1 + 2 raisedTo 2 + 2 raisedTo 3 + 2 raisedTo 4 + , , , + 2 raisedTo n
As we showed on page 44, this is 2 raisedTo n+1. Therefore, the runtime to compute the first n Fibonacci numbers
(using this terrible algorithm) is still O( 2 raisedTo n).

Example 15
==========
The following code prints all Fibonacci numbers from 0 to n. However, this time, it stores (i.e., caches) previously
computed values in an integer array. If it has already been computed, it just returns the cache. What is its runtime?
1 void allFib(int n) {
2   int[] memo = new int[n + 1];
3   for (int i= 0; i < n; i++) {
4     System.out.println(i + ": "+ fib(i, memo));
5   }
6 }
7
8 int fib(int n, int[] memo) {
9   if (n <= 0) 
       return 0;
10  else if (n == 1)
       return 1;
11  else if (memo[n] > 0) 
       return memo[n];
13  memo[n] = fib(n - 1, memo)+ fib(n - 2, memo);
14  return memo[n];
15 }
Let's walk through what this algorithm does.
fib(l) -> return 1
 fib(2)
  fib(l) -> return 1
  fib(0) -> return 0
  store 1 at memo[2]
fib(3)
  fib(2) -> lookup memo[2] -> return 1
  fib(l) -> return 1
  store 2 at memo[3]
fib(4)
  fib(3) -> lookup memo[3] -> return 2
  fib(2) -> lookup memo[2] -> return 1
  store 3 at memo[4]
fib(S)
  fib(4) -> lookup memo[4] -> return 3
  fib(3) -> lookup memo[3] -> return 2
  store 5 at memo[5]
  
At each call to fib(i), we have already computed and stored the values for fib(i-1) and fib(i-2).
We just look up those values, sum them, store the new result, and return. This takes a constant amount of
time.
We're doing a constant amount of work N times, so this is O (n) time.
This technique, called memoization, is a very common one to optimize exponential time recursive algorithms.
